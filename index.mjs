/**
 * The njs request object defined at http://nginx.org/en/docs/njs/reference.html#http
 * This type is not complete, just the elements relevant to operation of this library
 * @typedef {Object} NJSRequest
 * @property {function} getReport - Returns the current tracked memory state
 */

/**
 * The report generated by the profiler.
 * @typedef {Object} Report
 * @property {function} getReport - Returns the current tracked memory state
 */

/**
 * An object representing the profiler. Provides methods
 * to track events, and get the current profile at any point
 * @typedef {Object} Profiler
 * @property {function} getReport - Returns the current tracked memory state
 * @property {function} pushEvent - A function that allows specification of a named event.
 */

/**
 * Initializes the memory profiler. Call this function as
 * early as possible in your handler
 * @param NJSRequest r - the njs request object.
 * @param {function} reporterFn - function that takes the output and reports it. Built in options are `logReporter`, `fileReporter` functions provided in this module
 */
// required js_var declarations:
// $profile_id, $profile_events, $profile_begin, $profile_end
// $profile_elapsed_time_ms, $profile_memory_growth_bytes
// $profile_memory_growth_blocks
// include profiler_vars.conf in `http` or lower
function init(r, reporterFn) {
  // Check that js var declarations are done
  r.variables.profile_id = r.variables.request_id;
  r.variables.profile_begin = serialize(
    Object.assign({ req_start_ms: Date.now() }, njs.memoryStats)
  );
  r.variables.profile_events = serialize([]);
  const reporter = reporterFn === null ? null : reporterFn || logReporter;

  if (reporter) {
    njs.on("exit", () => {
      // No async work in this context
      reporter(getReport(r), r);
    });
  }
}

function pushEvent(r, event, meta) {
  meta = meta || {};
  meta.created_at_ms = Date.now();

  const events = deserialize(r.variables.profile_events);
  events.push({
    event,
    meta,
    raw_stats: nonStaticMemoryStats(njs.memoryStats),
  });

  r.variables.profile_events = serialize(events);
}

function getReport(r) {
  const req_end_ms = Date.now();
  const begin = deserialize(r.variables.profile_begin);
  return {
    request_id: r.variables.profile_id,
    cluster_size: begin.cluster_size,
    page_size: begin.page_size,
    begin:  nonStaticMemoryStats(begin),
    end: Object.assign({ req_end_ms }, nonStaticMemoryStats(njs.memoryStats)),
    growth: diff(begin, njs.memoryStats),
    elapsed_time_ms: req_end_ms - begin.req_start_ms,
    events: deserialize(r.variables.profile_events)
  };
}

function serialize(obj) {
  return JSON.stringify(obj);
}

function deserialize(string_obj) {
  return JSON.parse(string_obj);
}

function varReporter(report, r) {
  r.error(`In the varReporter, ${JSON.stringify(report)}`);
  r.variables.profile_end = serialize(report.end);
  r.variables.profile_elapsed_time_ms = report.elapsed_time_ms;
  r.variables.profile_memory_growth_bytes = report.growth.size_growth;
  r.variables.profile_memory_growth_blocks = report.growth.nblocks_growth;
}

function logReporter(report, r) {
  r.error(`{"type": "profiler:summary", "payload": ${JSON.stringify(report)} }`);
}

function fileReporter(report) {
  const fs = require("fs");

  return fs.writeFileSync(`${report.request_id}.json`, JSON.stringify(report));
}

function nonStaticMemoryStats(rawStats) {
  return {
    size: rawStats.size,
    nblocks: rawStats.nblocks,
  };
}

function diff(initial, point) {
  return {
    size_growth: point.size - initial.size,
    nblocks_growth: point.nblocks - initial.nblocks,
  };
}

export default { init, pushEvent, logReporter, fileReporter, getReport, varReporter };
